# 37.智能指针



![Slide1](37.智能指针分析.assets/Slide1.PNG)



![Slide2](37.智能指针分析.assets/Slide2.PNG)



![Slide3](37.智能指针分析.assets/Slide3.PNG)

```cpp
#include <iostream>
#include <string>

using namespace std;

class Test
{
    int i;
public:
    Test(int i)
    {
        this->i = i;
    }
    int value()
    {
        return i;
    }
    ~Test()
    {
    }
};

int main()
{
    for(int i=0; i<5; i++)
    {
        Test* p = new Test(i);
        
        cout << p->value() << endl;
        
    
    }
    
    return 0;
}

```

![Slide4](37.智能指针分析.assets/Slide4.PNG)



![Slide5](37.智能指针分析.assets/Slide5.PNG)

**重载对象模拟指针得行为**

![Slide6](37.智能指针分析.assets/Slide6.PNG)

```cpp
#include <iostream>
#include <string>

using namespace std;

class Test
{
    int i;
public:
    Test(int i)
    {
        cout << "Test(int i)" << endl;
        this->i = i;
    }
    int value()
    {
        return i;
    }
    ~Test()
    {
        cout << "~Test()" << endl;
    }
};

class Pointer
{
    Test* mp;
public:
    Pointer(Test* p = NULL)
    {
        mp = p;
    }
    Pointer(const Pointer& obj)
    {
        mp = obj.mp;
        const_cast<Pointer&>(obj).mp = NULL; // 去除只读属性
    }
    Pointer& operator = (const Pointer& obj)
    {
        if( this != &obj )
        {
            delete mp;
            mp = obj.mp;
            const_cast<Pointer&>(obj).mp = NULL; // 去除只读属性
        }
        
        return *this;
    }
    Test* operator -> ()
    {
        return mp;
    }
    Test& operator * ()
    {
        return *mp;
    }
    bool isNull()
    {
        return (mp == NULL);
    }
    ~Pointer()
    {
        delete mp;
    }
};

int main()
{
    Pointer p1 = new Test(0); // 就是Test* p1 = new  Test(0);
    
    cout << p1->value() << endl;
    
    Pointer p2 = p1;
    
    cout << p1.isNull() << endl;
    
    cout << p2->value() << endl;
    
    return 0;
}

```

![Slide7](37.智能指针分析.assets/Slide7.PNG)



**不能指向栈空间得地址**

![Slide8](37.智能指针分析.assets/Slide8.PNG)