# 42.类型转换函数(下)



![Slide1](42.类型转换函数(下).assets/Slide1.PNG)



![Slide2](42.类型转换函数(下).assets/Slide2.PNG)



![Slide3](42.类型转换函数(下).assets/Slide3.PNG)



![Slide4](42.类型转换函数(下).assets/Slide4.PNG)

```cpp
#include <iostream>
#include <string>

using namespace std;

class Test
{
    int mValue;
public:
    Test(int i = 0)
    {
        mValue = i;
    }
    int value()
    {
        return mValue;
    }
    operator int () // 类型转换函数->可以简单替换查表法
    {
        return mValue;
    }
};

int main()
{   
    Test t(100);
    int i = t; // 隐式调用t.operator int();
    
    cout << "t.value() = " << t.value() << endl; // 100
    cout << "i = " << i << endl; // 100
    
    return 0;
}

```

![Slide5](42.类型转换函数(下).assets/Slide5.PNG)



![Slide6](42.类型转换函数(下).assets/Slide6.PNG)

**哈哈哈哈其实可以看看gcc得源码才知道解析规则**

![Slide7](42.类型转换函数(下).assets/Slide7.PNG)



![Slide8](42.类型转换函数(下).assets/Slide8.PNG)

```cpp
#include <iostream>
#include <string>

using namespace std;

class Test;

class Value
{
public:
    Value()
    {
    }
    explicit Value(Test& t)
    {
    }
};

class Test
{
    int mValue;
public:
    Test(int i = 0)
    {
        mValue = i;
    }
    int value()
    {
        return mValue;
    }
    operator Value()
    {
        Value ret;
        cout << "operator Value()" << endl;
        return ret;
    }
};

int main()
{   
    Test t(100);
    Value v = t; // 隐式调用t.operator Value();
                 // 隐式调用Value(t)；
                 // 同时出现就有二义性，加explicit显式转换函数
    return 0;
}

```

![Slide9](42.类型转换函数(下).assets/Slide9.PNG)

```
// QT里面得实现
#include <QDebug>
#include <QString>

int main()
{
    QString str = "";
    int i = 0;
    double d = 0;
    short s = 0;

    str = "-255";
    i = str.toInt();
    d = str.toDouble();
    s = str.toShort();

    qDebug() << "i = " << i << endl;
    qDebug() << "d = " << d << endl;
    qDebug() << "s = " << s << endl;

    return 0;
}

```

![Slide10](42.类型转换函数(下).assets/Slide10.PNG)