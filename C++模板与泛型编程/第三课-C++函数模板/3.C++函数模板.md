# C++函数模板

## 第一节-函数模板

* 模板的定义是以`template`关键字开头;
* 类型模板参数T前面用`typename`来修饰，所以，遇到`typename`就该知道其后面跟的是一个类型。`typename`可以被class取代，但此处的class并没有“类”；
* 类型模板参数`T（代表是一个类型）`以前前面的`修饰符typename/class都用<>括起来`
* T这个名字可以换成任意其他标识符，对程序没有影响。**用T只是一种编程习惯**。

例子：

```cpp
namespace _nmsp1
{
	int Sub(int tv1, int tv2)
	{
		return tv1 - tv2;
	}

	float Sub(float tv1, float tv2)
	{
		return tv1 - tv2;
	}
}
```

使用函数模板：

```cpp
namespace _nmsp1
{
	template <typename T>  //T:称为 类型 模板参数，代表的是一个类型。
	// template <class T>  //class 可以取代typename，但是这里的class并没有“类”,只是表示后面的T是一							  //个类型,T这个名字可以任意起
	T Sub(T tv1, T tv2)    //给进去的T必须支持减法操作,编译器会做检查
	{
		return tv1 - tv2;
	}
}
```

### 实例化

实例化：在编译器编译的时候，用具体的类型来代替”**类型模板参数**“的过程（有人也叫代码生成器）

VS上面通过dumpbin命令查看.obj文件可以查看到

```
.obj文件的格式一般会被认为是一种COFF----通用对象文件格式（Common Object File Format）。
```

Linux可以看.o文件

```cpp
int  Sub<int>(int,int)
double Sub<double>(double,double)
实例化之后的函数名分别叫做Sub<int>和Sub<double>
```

通过函数模板实例化之后的函数名包含三部分：

* a)模板名；
* b)后面跟着一对<>；
* c)<>中间是一个具体类型。

​     编译期间->实例化具体的sub函数

​    在编译阶段，编译器就会查看函数模板的函数体部分，来确定能否针对该类型string进行Sub函数模板的实例化。

在编译阶段，**编译器需要能够找到函数模板的函数体部分**。

**在工程中，需要将函数模板包括头和体都要包含在头文件中；**

### 模板参数的推断

* 常见的参数推断

  ```cpp
  namespace _nmsp1
  {
  	//-------------------------------------------------
  	template <typename T,typename U,typename V>
      
  	V Add(T tv1, U tv2)
  	{
  		return tv1 + tv2;
  	}
      
      template <typename V,typename T,typename U>
      
      V Add1(T tv1, U tv2) 
      {
          return tv1 + tv2;
      }
      
      template <typename T, typename U>
      
      auto Add2(T tv1, U tv2) // auto用于表达式推导返回类型的含义
      {
          return tv1 + tv2;
      }
      
       
      template <typename T, typename U>
      
      auto Add3(T tv1, U tv2)-> decltype(tv1 + tv2) // 返回类型后置语法,这里的auto只是返回类型
      {                                             // 后置语法的一部分，并没有类型推导的含义
          return tv1 + tv2;
      }
      
  }
  
  int main()
  {
  	cout << _nmsp1::Add(15, 17,8) << endl;
      // error: _nmsp1::Add未能找到匹配的重载函数
      // 未能为"V"推导模板参数,没有能提推断出返回值
      // 怎么改呢？
      // cout << _nmsp1::Add<...,...double>(15, 17.8)没有这种语法
      cout << _nmsp1::Add<int, double, double>(15, 17.8); // ok麻烦可可以值指定一部分模板参数嘛？
      // 方法二：
      cout << _nmsp1::Add1<double>(15, 17.8); // // 通过<>可以只指定一部分模板参数的类型，另外一部分模板参数的类型可以通过调用时给的实参来推断。但是一旦开始了推断就必须让它都是自动推断
      // 方法三：
      cout << _nmsp1::Add2(15, 17.8) << endl; // 使用auto是可以的，C++17里面增强auto的功能
      // decltype,可以与auto结合使用来构成返回类型后置语法。
      // 这种后置语法其实也就是使用auto和decltype结合来完成返回值类型的推导。
      cout << _nmsp1::Add3(15, 17.8) << endl;
      return 0;
  }
  ```

* 各种推断的比较以及空模板参数列表的推断
  * 自动推断
  * **指定类型模板参数,优先级比自动推断高**
  * **指定空模板参数列表<>：作用就是请调用mydouble函数模板而不是调用普通的mydouble函数。**

```cpp
namespace _nmsp1
{
	template <typename T>
	T mydouble(T tmpvalue)
	{
		return tmpvalue * 2;
	}

	double mydouble(double tmpvalue)
	{
		return tmpvalue * 2;
	}
}

int main()
{
    cout << _nmsp1::mydouble(15) << endl;        // 可以推断出T类型是int类型
    int result2 = _nmsp1::mydouble<int>(16.9);   // 显示指定了类型有警告double->int
    auto result3 = _nmsp1::mydouble<>(16.9)      // 这种写法编译器是通过16.9推导是double类型 
    											 // 此种场合下，空的<>没有用处,但语法上允许
    auto result4 = _nmsp1::mydouble(16.9);       // 在模板和普通函数都适合的情况下，编译器会优先调													// 用普通函数
    auto result5 = _nmsp1::mydouble<>(16.9);     // 告诉编译器调用模板函数
    reutrn 0;
}
```

